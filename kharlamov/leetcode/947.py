class Solution:
    def removeStones(self, stones: List[List[int]]) -> int:
        # Подготовка графа
        graph = defaultdict(list)  # Создаем пустой граф с использованием defaultdict, чтобы автоматически создавать списки смежных вершин
        for i, (x1, y1) in enumerate(stones):  # Перебираем камни, нумеруя их
            for j, (x2, y2) in enumerate(stones):  # Для каждого камня перебираем остальные камни
                if x1 == x2 or y1 == y2:  # Если координаты камней совпадают по x или по y
                    graph[i].append(j)  # Добавляем номер смежной вершины в список смежных вершин для текущего камня

        def dfs(node):
            visited.add(node)  # Добавляем текущую вершину в множество посещенных вершин
            for nei in graph[node]:  # Перебираем смежные вершины текущей вершины
                if nei not in visited:  # Если смежная вершина не была посещена
                    dfs(nei)  # Рекурсивно запускаем DFS для этой смежной вершины

        visited = set()  # Создаем пустое множество для отслеживания посещенных вершин
        components = 0  # Инициализируем количество компонент
        for node in range(len(stones)):  # Перебираем все вершины (камни)
            if node not in visited:  # Если текущая вершина не была посещена
                dfs(node)  # Запускаем DFS для поиска сильно связанных компонент
                components += 1  # Увеличиваем количество компонент

        # Вычитаем количество сильно связанных компонент из общего количества камней
        return len(stones) - components
